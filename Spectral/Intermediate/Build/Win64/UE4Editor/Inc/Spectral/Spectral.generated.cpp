// Copyright 1998-2015 Epic Games, Inc. All Rights Reserved.
/*===========================================================================
	Boilerplate C++ definitions for a single module.
	This is automatically generated by UnrealHeaderTool.
	DO NOT modify this manually! Edit the corresponding .h files instead!
===========================================================================*/

#include "Spectral.h"
#include "Spectral.generated.dep.h"
PRAGMA_DISABLE_DEPRECATION_WARNINGS
void EmptyLinkFunctionForGeneratedCodeSpectral() {}
	void USkillEffectFactoryIntf::StaticRegisterNativesUSkillEffectFactoryIntf()
	{
	}
	IMPLEMENT_CLASS(USkillEffectFactoryIntf, 1695646184);
	void ISkillEffectIntf::ApplyEffect(const TScriptInterface<ISkillUserIntf>& Skill)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_ApplyEffect instead.");
	}
	TScriptInterface<ISkillEffectStorageIntf> ISkillEffectIntf::GetStorage()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_GetStorage instead.");
		SkillEffectIntf_eventGetStorage_Parms Parms;
		return Parms.ReturnValue;
	}
	void ISkillEffectIntf::RevertEffect(const TScriptInterface<ISkillUserIntf>& Skill)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_RevertEffect instead.");
	}
	void USkillEffectIntf::StaticRegisterNativesUSkillEffectIntf()
	{
		FNativeFunctionRegistrar::RegisterFunction(USkillEffectIntf::StaticClass(),"ApplyEffect",(Native)&ISkillEffectIntf::execApplyEffect);
		FNativeFunctionRegistrar::RegisterFunction(USkillEffectIntf::StaticClass(),"GetStorage",(Native)&ISkillEffectIntf::execGetStorage);
		FNativeFunctionRegistrar::RegisterFunction(USkillEffectIntf::StaticClass(),"RevertEffect",(Native)&ISkillEffectIntf::execRevertEffect);
	}
	IMPLEMENT_CLASS(USkillEffectIntf, 310783875);
	void ISkillEffectIntf::Execute_ApplyEffect(UObject* O, const TScriptInterface<ISkillUserIntf>& Skill)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(USkillEffectIntf::StaticClass()));
		SkillEffectIntf_eventApplyEffect_Parms Parms;
		UFunction* const Func = O->FindFunction(SPECTRAL_ApplyEffect);
		if (Func)
		{
			Parms.Skill=Skill;
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (ISkillEffectIntf*)(O->GetNativeInterfaceAddress(USkillEffectIntf::StaticClass())))
		{
			I->ApplyEffect_Implementation(Skill);
		}
	}
	TScriptInterface<ISkillEffectStorageIntf> ISkillEffectIntf::Execute_GetStorage(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(USkillEffectIntf::StaticClass()));
		SkillEffectIntf_eventGetStorage_Parms Parms;
		UFunction* const Func = O->FindFunction(SPECTRAL_GetStorage);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (ISkillEffectIntf*)(O->GetNativeInterfaceAddress(USkillEffectIntf::StaticClass())))
		{
			Parms.ReturnValue = I->GetStorage_Implementation();
		}
		return Parms.ReturnValue;
	}
	void ISkillEffectIntf::Execute_RevertEffect(UObject* O, const TScriptInterface<ISkillUserIntf>& Skill)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(USkillEffectIntf::StaticClass()));
		SkillEffectIntf_eventRevertEffect_Parms Parms;
		UFunction* const Func = O->FindFunction(SPECTRAL_RevertEffect);
		if (Func)
		{
			Parms.Skill=Skill;
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (ISkillEffectIntf*)(O->GetNativeInterfaceAddress(USkillEffectIntf::StaticClass())))
		{
			I->RevertEffect_Implementation(Skill);
		}
	}
	TScriptInterface<ISkillEffectIntf> ISkillEffectStorageIntf::AddSkillEffect(const TScriptInterface<ISkillEffectIntf>& SkillEffect, int32 Index)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_AddSkillEffect instead.");
		SkillEffectStorageIntf_eventAddSkillEffect_Parms Parms;
		return Parms.ReturnValue;
	}
	TArray<TScriptInterface<ISkillEffectIntf> > ISkillEffectStorageIntf::GetSkillEffects() const
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_GetSkillEffects instead.");
		SkillEffectStorageIntf_eventGetSkillEffects_Parms Parms;
		return Parms.ReturnValue;
	}
	void ISkillEffectStorageIntf::RemoveSkillEffectByIndex(int32 Index)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_RemoveSkillEffectByIndex instead.");
	}
	void ISkillEffectStorageIntf::RemoveSkillEffectByRef(const TScriptInterface<ISkillEffectIntf>& SkillEffect)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_RemoveSkillEffectByRef instead.");
	}
	void USkillEffectStorageIntf::StaticRegisterNativesUSkillEffectStorageIntf()
	{
		FNativeFunctionRegistrar::RegisterFunction(USkillEffectStorageIntf::StaticClass(),"AddSkillEffect",(Native)&ISkillEffectStorageIntf::execAddSkillEffect);
		FNativeFunctionRegistrar::RegisterFunction(USkillEffectStorageIntf::StaticClass(),"GetSkillEffects",(Native)&ISkillEffectStorageIntf::execGetSkillEffects);
		FNativeFunctionRegistrar::RegisterFunction(USkillEffectStorageIntf::StaticClass(),"RemoveSkillEffectByIndex",(Native)&ISkillEffectStorageIntf::execRemoveSkillEffectByIndex);
		FNativeFunctionRegistrar::RegisterFunction(USkillEffectStorageIntf::StaticClass(),"RemoveSkillEffectByRef",(Native)&ISkillEffectStorageIntf::execRemoveSkillEffectByRef);
	}
	IMPLEMENT_CLASS(USkillEffectStorageIntf, 70095828);
	TScriptInterface<ISkillEffectIntf> ISkillEffectStorageIntf::Execute_AddSkillEffect(UObject* O, const TScriptInterface<ISkillEffectIntf>& SkillEffect, int32 Index)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(USkillEffectStorageIntf::StaticClass()));
		SkillEffectStorageIntf_eventAddSkillEffect_Parms Parms;
		UFunction* const Func = O->FindFunction(SPECTRAL_AddSkillEffect);
		if (Func)
		{
			Parms.SkillEffect=SkillEffect;
			Parms.Index=Index;
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (ISkillEffectStorageIntf*)(O->GetNativeInterfaceAddress(USkillEffectStorageIntf::StaticClass())))
		{
			Parms.ReturnValue = I->AddSkillEffect_Implementation(SkillEffect,Index);
		}
		return Parms.ReturnValue;
	}
	TArray<TScriptInterface<ISkillEffectIntf> > ISkillEffectStorageIntf::Execute_GetSkillEffects(const UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(USkillEffectStorageIntf::StaticClass()));
		SkillEffectStorageIntf_eventGetSkillEffects_Parms Parms;
		UFunction* const Func = O->FindFunction(SPECTRAL_GetSkillEffects);
		if (Func)
		{
			const_cast<UObject*>(O)->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (const ISkillEffectStorageIntf*)(O->GetNativeInterfaceAddress(USkillEffectStorageIntf::StaticClass())))
		{
			Parms.ReturnValue = I->GetSkillEffects_Implementation();
		}
		return Parms.ReturnValue;
	}
	void ISkillEffectStorageIntf::Execute_RemoveSkillEffectByIndex(UObject* O, int32 Index)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(USkillEffectStorageIntf::StaticClass()));
		SkillEffectStorageIntf_eventRemoveSkillEffectByIndex_Parms Parms;
		UFunction* const Func = O->FindFunction(SPECTRAL_RemoveSkillEffectByIndex);
		if (Func)
		{
			Parms.Index=Index;
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (ISkillEffectStorageIntf*)(O->GetNativeInterfaceAddress(USkillEffectStorageIntf::StaticClass())))
		{
			I->RemoveSkillEffectByIndex_Implementation(Index);
		}
	}
	void ISkillEffectStorageIntf::Execute_RemoveSkillEffectByRef(UObject* O, const TScriptInterface<ISkillEffectIntf>& SkillEffect)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(USkillEffectStorageIntf::StaticClass()));
		SkillEffectStorageIntf_eventRemoveSkillEffectByRef_Parms Parms;
		UFunction* const Func = O->FindFunction(SPECTRAL_RemoveSkillEffectByRef);
		if (Func)
		{
			Parms.SkillEffect=SkillEffect;
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (ISkillEffectStorageIntf*)(O->GetNativeInterfaceAddress(USkillEffectStorageIntf::StaticClass())))
		{
			I->RemoveSkillEffectByRef_Implementation(SkillEffect);
		}
	}
	TScriptInterface<ISkillIntf> ISkillExecutorIntf::GetSkill()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_GetSkill instead.");
		SkillExecutorIntf_eventGetSkill_Parms Parms;
		return Parms.ReturnValue;
	}
	TScriptInterface<ISkillUserIntf> ISkillExecutorIntf::GetSkillOwner()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_GetSkillOwner instead.");
		SkillExecutorIntf_eventGetSkillOwner_Parms Parms;
		return Parms.ReturnValue;
	}
	void USkillExecutorIntf::StaticRegisterNativesUSkillExecutorIntf()
	{
		FNativeFunctionRegistrar::RegisterFunction(USkillExecutorIntf::StaticClass(),"GetSkill",(Native)&ISkillExecutorIntf::execGetSkill);
		FNativeFunctionRegistrar::RegisterFunction(USkillExecutorIntf::StaticClass(),"GetSkillOwner",(Native)&ISkillExecutorIntf::execGetSkillOwner);
	}
	IMPLEMENT_CLASS(USkillExecutorIntf, 580390892);
	TScriptInterface<ISkillIntf> ISkillExecutorIntf::Execute_GetSkill(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(USkillExecutorIntf::StaticClass()));
		SkillExecutorIntf_eventGetSkill_Parms Parms;
		UFunction* const Func = O->FindFunction(SPECTRAL_GetSkill);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (ISkillExecutorIntf*)(O->GetNativeInterfaceAddress(USkillExecutorIntf::StaticClass())))
		{
			Parms.ReturnValue = I->GetSkill_Implementation();
		}
		return Parms.ReturnValue;
	}
	TScriptInterface<ISkillUserIntf> ISkillExecutorIntf::Execute_GetSkillOwner(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(USkillExecutorIntf::StaticClass()));
		SkillExecutorIntf_eventGetSkillOwner_Parms Parms;
		UFunction* const Func = O->FindFunction(SPECTRAL_GetSkillOwner);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (ISkillExecutorIntf*)(O->GetNativeInterfaceAddress(USkillExecutorIntf::StaticClass())))
		{
			Parms.ReturnValue = I->GetSkillOwner_Implementation();
		}
		return Parms.ReturnValue;
	}
	void USkillFactoryIntf::StaticRegisterNativesUSkillFactoryIntf()
	{
	}
	IMPLEMENT_CLASS(USkillFactoryIntf, 1663338449);
	void ISkillIntf::ApplySkill(const TScriptInterface<ISkillUserIntf>& Target)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_ApplySkill instead.");
	}
	TScriptInterface<ISkillEffectStorageIntf> ISkillIntf::GetEffectStorage()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_GetEffectStorage instead.");
		SkillIntf_eventGetEffectStorage_Parms Parms;
		return Parms.ReturnValue;
	}
	TScriptInterface<ISkillModStorageIntf> ISkillIntf::GetModStorage()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_GetModStorage instead.");
		SkillIntf_eventGetModStorage_Parms Parms;
		return Parms.ReturnValue;
	}
	TScriptInterface<ISkillExecutorIntf> ISkillIntf::GetSkillExecutor()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_GetSkillExecutor instead.");
		SkillIntf_eventGetSkillExecutor_Parms Parms;
		return Parms.ReturnValue;
	}
	void USkillIntf::StaticRegisterNativesUSkillIntf()
	{
		FNativeFunctionRegistrar::RegisterFunction(USkillIntf::StaticClass(),"ApplySkill",(Native)&ISkillIntf::execApplySkill);
		FNativeFunctionRegistrar::RegisterFunction(USkillIntf::StaticClass(),"GetEffectStorage",(Native)&ISkillIntf::execGetEffectStorage);
		FNativeFunctionRegistrar::RegisterFunction(USkillIntf::StaticClass(),"GetModStorage",(Native)&ISkillIntf::execGetModStorage);
		FNativeFunctionRegistrar::RegisterFunction(USkillIntf::StaticClass(),"GetSkillExecutor",(Native)&ISkillIntf::execGetSkillExecutor);
	}
	IMPLEMENT_CLASS(USkillIntf, 1839935160);
	void ISkillIntf::Execute_ApplySkill(UObject* O, const TScriptInterface<ISkillUserIntf>& Target)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(USkillIntf::StaticClass()));
		SkillIntf_eventApplySkill_Parms Parms;
		UFunction* const Func = O->FindFunction(SPECTRAL_ApplySkill);
		if (Func)
		{
			Parms.Target=Target;
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (ISkillIntf*)(O->GetNativeInterfaceAddress(USkillIntf::StaticClass())))
		{
			I->ApplySkill_Implementation(Target);
		}
	}
	TScriptInterface<ISkillEffectStorageIntf> ISkillIntf::Execute_GetEffectStorage(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(USkillIntf::StaticClass()));
		SkillIntf_eventGetEffectStorage_Parms Parms;
		UFunction* const Func = O->FindFunction(SPECTRAL_GetEffectStorage);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (ISkillIntf*)(O->GetNativeInterfaceAddress(USkillIntf::StaticClass())))
		{
			Parms.ReturnValue = I->GetEffectStorage_Implementation();
		}
		return Parms.ReturnValue;
	}
	TScriptInterface<ISkillModStorageIntf> ISkillIntf::Execute_GetModStorage(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(USkillIntf::StaticClass()));
		SkillIntf_eventGetModStorage_Parms Parms;
		UFunction* const Func = O->FindFunction(SPECTRAL_GetModStorage);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (ISkillIntf*)(O->GetNativeInterfaceAddress(USkillIntf::StaticClass())))
		{
			Parms.ReturnValue = I->GetModStorage_Implementation();
		}
		return Parms.ReturnValue;
	}
	TScriptInterface<ISkillExecutorIntf> ISkillIntf::Execute_GetSkillExecutor(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(USkillIntf::StaticClass()));
		SkillIntf_eventGetSkillExecutor_Parms Parms;
		UFunction* const Func = O->FindFunction(SPECTRAL_GetSkillExecutor);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (ISkillIntf*)(O->GetNativeInterfaceAddress(USkillIntf::StaticClass())))
		{
			Parms.ReturnValue = I->GetSkillExecutor_Implementation();
		}
		return Parms.ReturnValue;
	}
	void USkillModFactoryIntf::StaticRegisterNativesUSkillModFactoryIntf()
	{
	}
	IMPLEMENT_CLASS(USkillModFactoryIntf, 3750361662);
	void ISkillModIntf::ApplyMod(const TScriptInterface<ISkillIntf>& Skill)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_ApplyMod instead.");
	}
	void ISkillModIntf::RevertMod(const TScriptInterface<ISkillIntf>& Skill)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_RevertMod instead.");
	}
	void USkillModIntf::StaticRegisterNativesUSkillModIntf()
	{
		FNativeFunctionRegistrar::RegisterFunction(USkillModIntf::StaticClass(),"ApplyMod",(Native)&ISkillModIntf::execApplyMod);
		FNativeFunctionRegistrar::RegisterFunction(USkillModIntf::StaticClass(),"RevertMod",(Native)&ISkillModIntf::execRevertMod);
	}
	IMPLEMENT_CLASS(USkillModIntf, 4047467727);
	void ISkillModIntf::Execute_ApplyMod(UObject* O, const TScriptInterface<ISkillIntf>& Skill)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(USkillModIntf::StaticClass()));
		SkillModIntf_eventApplyMod_Parms Parms;
		UFunction* const Func = O->FindFunction(SPECTRAL_ApplyMod);
		if (Func)
		{
			Parms.Skill=Skill;
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (ISkillModIntf*)(O->GetNativeInterfaceAddress(USkillModIntf::StaticClass())))
		{
			I->ApplyMod_Implementation(Skill);
		}
	}
	void ISkillModIntf::Execute_RevertMod(UObject* O, const TScriptInterface<ISkillIntf>& Skill)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(USkillModIntf::StaticClass()));
		SkillModIntf_eventRevertMod_Parms Parms;
		UFunction* const Func = O->FindFunction(SPECTRAL_RevertMod);
		if (Func)
		{
			Parms.Skill=Skill;
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (ISkillModIntf*)(O->GetNativeInterfaceAddress(USkillModIntf::StaticClass())))
		{
			I->RevertMod_Implementation(Skill);
		}
	}
	void ISkillModStorageIntf::AddSkillMod(const TScriptInterface<ISkillModIntf>& SkillMod)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_AddSkillMod instead.");
	}
	TArray<TScriptInterface<ISkillModIntf> > ISkillModStorageIntf::GetSkillMods() const
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_GetSkillMods instead.");
		SkillModStorageIntf_eventGetSkillMods_Parms Parms;
		return Parms.ReturnValue;
	}
	void ISkillModStorageIntf::RemoveSkillModByIndex(int32 Index)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_RemoveSkillModByIndex instead.");
	}
	void ISkillModStorageIntf::RemoveSkillModByRef(const TScriptInterface<ISkillModIntf>& SkillMod)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_RemoveSkillModByRef instead.");
	}
	void USkillModStorageIntf::StaticRegisterNativesUSkillModStorageIntf()
	{
		FNativeFunctionRegistrar::RegisterFunction(USkillModStorageIntf::StaticClass(),"AddSkillMod",(Native)&ISkillModStorageIntf::execAddSkillMod);
		FNativeFunctionRegistrar::RegisterFunction(USkillModStorageIntf::StaticClass(),"GetSkillMods",(Native)&ISkillModStorageIntf::execGetSkillMods);
		FNativeFunctionRegistrar::RegisterFunction(USkillModStorageIntf::StaticClass(),"RemoveSkillModByIndex",(Native)&ISkillModStorageIntf::execRemoveSkillModByIndex);
		FNativeFunctionRegistrar::RegisterFunction(USkillModStorageIntf::StaticClass(),"RemoveSkillModByRef",(Native)&ISkillModStorageIntf::execRemoveSkillModByRef);
	}
	IMPLEMENT_CLASS(USkillModStorageIntf, 113707801);
	void ISkillModStorageIntf::Execute_AddSkillMod(UObject* O, const TScriptInterface<ISkillModIntf>& SkillMod)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(USkillModStorageIntf::StaticClass()));
		SkillModStorageIntf_eventAddSkillMod_Parms Parms;
		UFunction* const Func = O->FindFunction(SPECTRAL_AddSkillMod);
		if (Func)
		{
			Parms.SkillMod=SkillMod;
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (ISkillModStorageIntf*)(O->GetNativeInterfaceAddress(USkillModStorageIntf::StaticClass())))
		{
			I->AddSkillMod_Implementation(SkillMod);
		}
	}
	TArray<TScriptInterface<ISkillModIntf> > ISkillModStorageIntf::Execute_GetSkillMods(const UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(USkillModStorageIntf::StaticClass()));
		SkillModStorageIntf_eventGetSkillMods_Parms Parms;
		UFunction* const Func = O->FindFunction(SPECTRAL_GetSkillMods);
		if (Func)
		{
			const_cast<UObject*>(O)->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (const ISkillModStorageIntf*)(O->GetNativeInterfaceAddress(USkillModStorageIntf::StaticClass())))
		{
			Parms.ReturnValue = I->GetSkillMods_Implementation();
		}
		return Parms.ReturnValue;
	}
	void ISkillModStorageIntf::Execute_RemoveSkillModByIndex(UObject* O, int32 Index)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(USkillModStorageIntf::StaticClass()));
		SkillModStorageIntf_eventRemoveSkillModByIndex_Parms Parms;
		UFunction* const Func = O->FindFunction(SPECTRAL_RemoveSkillModByIndex);
		if (Func)
		{
			Parms.Index=Index;
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (ISkillModStorageIntf*)(O->GetNativeInterfaceAddress(USkillModStorageIntf::StaticClass())))
		{
			I->RemoveSkillModByIndex_Implementation(Index);
		}
	}
	void ISkillModStorageIntf::Execute_RemoveSkillModByRef(UObject* O, const TScriptInterface<ISkillModIntf>& SkillMod)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(USkillModStorageIntf::StaticClass()));
		SkillModStorageIntf_eventRemoveSkillModByRef_Parms Parms;
		UFunction* const Func = O->FindFunction(SPECTRAL_RemoveSkillModByRef);
		if (Func)
		{
			Parms.SkillMod=SkillMod;
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (ISkillModStorageIntf*)(O->GetNativeInterfaceAddress(USkillModStorageIntf::StaticClass())))
		{
			I->RemoveSkillModByRef_Implementation(SkillMod);
		}
	}
	void ISkillReactiveIntf::React()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_React instead.");
	}
	void USkillReactiveIntf::StaticRegisterNativesUSkillReactiveIntf()
	{
		FNativeFunctionRegistrar::RegisterFunction(USkillReactiveIntf::StaticClass(),"React",(Native)&ISkillReactiveIntf::execReact);
	}
	IMPLEMENT_CLASS(USkillReactiveIntf, 971437023);
	void ISkillReactiveIntf::Execute_React(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(USkillReactiveIntf::StaticClass()));
		UFunction* const Func = O->FindFunction(SPECTRAL_React);
		if (Func)
		{
			O->ProcessEvent(Func, NULL);
		}
		else if (auto I = (ISkillReactiveIntf*)(O->GetNativeInterfaceAddress(USkillReactiveIntf::StaticClass())))
		{
			I->React_Implementation();
		}
	}
	void ISkillStorageIntf::AddSkill(const TScriptInterface<ISkillIntf>& Skill)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_AddSkill instead.");
	}
	TArray<TScriptInterface<ISkillIntf> > ISkillStorageIntf::GetSkills() const
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_GetSkills instead.");
		SkillStorageIntf_eventGetSkills_Parms Parms;
		return Parms.ReturnValue;
	}
	void ISkillStorageIntf::RemoveSkillByIndex(int32 Index)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_RemoveSkillByIndex instead.");
	}
	void ISkillStorageIntf::RemoveSkillByRef(const TScriptInterface<ISkillIntf>& Skill)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_RemoveSkillByRef instead.");
	}
	void USkillStorageIntf::StaticRegisterNativesUSkillStorageIntf()
	{
		FNativeFunctionRegistrar::RegisterFunction(USkillStorageIntf::StaticClass(),"AddSkill",(Native)&ISkillStorageIntf::execAddSkill);
		FNativeFunctionRegistrar::RegisterFunction(USkillStorageIntf::StaticClass(),"GetSkills",(Native)&ISkillStorageIntf::execGetSkills);
		FNativeFunctionRegistrar::RegisterFunction(USkillStorageIntf::StaticClass(),"RemoveSkillByIndex",(Native)&ISkillStorageIntf::execRemoveSkillByIndex);
		FNativeFunctionRegistrar::RegisterFunction(USkillStorageIntf::StaticClass(),"RemoveSkillByRef",(Native)&ISkillStorageIntf::execRemoveSkillByRef);
	}
	IMPLEMENT_CLASS(USkillStorageIntf, 1689311349);
	void ISkillStorageIntf::Execute_AddSkill(UObject* O, const TScriptInterface<ISkillIntf>& Skill)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(USkillStorageIntf::StaticClass()));
		SkillStorageIntf_eventAddSkill_Parms Parms;
		UFunction* const Func = O->FindFunction(SPECTRAL_AddSkill);
		if (Func)
		{
			Parms.Skill=Skill;
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (ISkillStorageIntf*)(O->GetNativeInterfaceAddress(USkillStorageIntf::StaticClass())))
		{
			I->AddSkill_Implementation(Skill);
		}
	}
	TArray<TScriptInterface<ISkillIntf> > ISkillStorageIntf::Execute_GetSkills(const UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(USkillStorageIntf::StaticClass()));
		SkillStorageIntf_eventGetSkills_Parms Parms;
		UFunction* const Func = O->FindFunction(SPECTRAL_GetSkills);
		if (Func)
		{
			const_cast<UObject*>(O)->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (const ISkillStorageIntf*)(O->GetNativeInterfaceAddress(USkillStorageIntf::StaticClass())))
		{
			Parms.ReturnValue = I->GetSkills_Implementation();
		}
		return Parms.ReturnValue;
	}
	void ISkillStorageIntf::Execute_RemoveSkillByIndex(UObject* O, int32 Index)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(USkillStorageIntf::StaticClass()));
		SkillStorageIntf_eventRemoveSkillByIndex_Parms Parms;
		UFunction* const Func = O->FindFunction(SPECTRAL_RemoveSkillByIndex);
		if (Func)
		{
			Parms.Index=Index;
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (ISkillStorageIntf*)(O->GetNativeInterfaceAddress(USkillStorageIntf::StaticClass())))
		{
			I->RemoveSkillByIndex_Implementation(Index);
		}
	}
	void ISkillStorageIntf::Execute_RemoveSkillByRef(UObject* O, const TScriptInterface<ISkillIntf>& Skill)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(USkillStorageIntf::StaticClass()));
		SkillStorageIntf_eventRemoveSkillByRef_Parms Parms;
		UFunction* const Func = O->FindFunction(SPECTRAL_RemoveSkillByRef);
		if (Func)
		{
			Parms.Skill=Skill;
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (ISkillStorageIntf*)(O->GetNativeInterfaceAddress(USkillStorageIntf::StaticClass())))
		{
			I->RemoveSkillByRef_Implementation(Skill);
		}
	}
	TScriptInterface<ISkillExecutorIntf> ISkillUserIntf::GenerateSkillExecutor(const TArray<AActor*>& TargetingMethod, int32 SkillIndex)
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_GenerateSkillExecutor instead.");
		SkillUserIntf_eventGenerateSkillExecutor_Parms Parms;
		return Parms.ReturnValue;
	}
	TArray<TScriptInterface<ISkillIntf> > ISkillUserIntf::GetSkills()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_GetSkills instead.");
		SkillUserIntf_eventGetSkills_Parms Parms;
		return Parms.ReturnValue;
	}
	FVector ISkillUserIntf::GetSkillUserLocation()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_GetSkillUserLocation instead.");
		SkillUserIntf_eventGetSkillUserLocation_Parms Parms;
		return Parms.ReturnValue;
	}
	void USkillUserIntf::StaticRegisterNativesUSkillUserIntf()
	{
		FNativeFunctionRegistrar::RegisterFunction(USkillUserIntf::StaticClass(),"GenerateSkillExecutor",(Native)&ISkillUserIntf::execGenerateSkillExecutor);
		FNativeFunctionRegistrar::RegisterFunction(USkillUserIntf::StaticClass(),"GetSkills",(Native)&ISkillUserIntf::execGetSkills);
		FNativeFunctionRegistrar::RegisterFunction(USkillUserIntf::StaticClass(),"GetSkillUserLocation",(Native)&ISkillUserIntf::execGetSkillUserLocation);
	}
	IMPLEMENT_CLASS(USkillUserIntf, 2217716462);
	TScriptInterface<ISkillExecutorIntf> ISkillUserIntf::Execute_GenerateSkillExecutor(UObject* O, const TArray<AActor*>& TargetingMethod, int32 SkillIndex)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(USkillUserIntf::StaticClass()));
		SkillUserIntf_eventGenerateSkillExecutor_Parms Parms;
		UFunction* const Func = O->FindFunction(SPECTRAL_GenerateSkillExecutor);
		if (Func)
		{
			Parms.TargetingMethod=TargetingMethod;
			Parms.SkillIndex=SkillIndex;
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (ISkillUserIntf*)(O->GetNativeInterfaceAddress(USkillUserIntf::StaticClass())))
		{
			Parms.ReturnValue = I->GenerateSkillExecutor_Implementation(TargetingMethod,SkillIndex);
		}
		return Parms.ReturnValue;
	}
	TArray<TScriptInterface<ISkillIntf> > ISkillUserIntf::Execute_GetSkills(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(USkillUserIntf::StaticClass()));
		SkillUserIntf_eventGetSkills_Parms Parms;
		UFunction* const Func = O->FindFunction(SPECTRAL_GetSkills);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (ISkillUserIntf*)(O->GetNativeInterfaceAddress(USkillUserIntf::StaticClass())))
		{
			Parms.ReturnValue = I->GetSkills_Implementation();
		}
		return Parms.ReturnValue;
	}
	FVector ISkillUserIntf::Execute_GetSkillUserLocation(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(USkillUserIntf::StaticClass()));
		SkillUserIntf_eventGetSkillUserLocation_Parms Parms;
		UFunction* const Func = O->FindFunction(SPECTRAL_GetSkillUserLocation);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (ISkillUserIntf*)(O->GetNativeInterfaceAddress(USkillUserIntf::StaticClass())))
		{
			Parms.ReturnValue = I->GetSkillUserLocation_Implementation();
		}
		return Parms.ReturnValue;
	}
	void ASpectralGameMode::StaticRegisterNativesASpectralGameMode()
	{
	}
	IMPLEMENT_CLASS(ASpectralGameMode, 2145972497);
	void ASpectralPawn::StaticRegisterNativesASpectralPawn()
	{
	}
	IMPLEMENT_CLASS(ASpectralPawn, 310639511);
	void ASpectralProjectile::StaticRegisterNativesASpectralProjectile()
	{
		FNativeFunctionRegistrar::RegisterFunction(ASpectralProjectile::StaticClass(),"OnHit",(Native)&ASpectralProjectile::execOnHit);
	}
	IMPLEMENT_CLASS(ASpectralProjectile, 2429959699);
	void UTargetingPermissionsIntf::StaticRegisterNativesUTargetingPermissionsIntf()
	{
	}
	IMPLEMENT_CLASS(UTargetingPermissionsIntf, 697166191);
	FVector ITargetableIntf::GetTargetableLocation()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_GetTargetableLocation instead.");
		TargetableIntf_eventGetTargetableLocation_Parms Parms;
		return Parms.ReturnValue;
	}
	TScriptInterface<ITargetingPermissionsIntf> ITargetableIntf::GetTargetingPermissions()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_GetTargetingPermissions instead.");
		TargetableIntf_eventGetTargetingPermissions_Parms Parms;
		return Parms.ReturnValue;
	}
	void UTargetableIntf::StaticRegisterNativesUTargetableIntf()
	{
		FNativeFunctionRegistrar::RegisterFunction(UTargetableIntf::StaticClass(),"GetTargetableLocation",(Native)&ITargetableIntf::execGetTargetableLocation);
		FNativeFunctionRegistrar::RegisterFunction(UTargetableIntf::StaticClass(),"GetTargetingPermissions",(Native)&ITargetableIntf::execGetTargetingPermissions);
	}
	IMPLEMENT_CLASS(UTargetableIntf, 1172094518);
	FVector ITargetableIntf::Execute_GetTargetableLocation(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UTargetableIntf::StaticClass()));
		TargetableIntf_eventGetTargetableLocation_Parms Parms;
		UFunction* const Func = O->FindFunction(SPECTRAL_GetTargetableLocation);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (ITargetableIntf*)(O->GetNativeInterfaceAddress(UTargetableIntf::StaticClass())))
		{
			Parms.ReturnValue = I->GetTargetableLocation_Implementation();
		}
		return Parms.ReturnValue;
	}
	TScriptInterface<ITargetingPermissionsIntf> ITargetableIntf::Execute_GetTargetingPermissions(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UTargetableIntf::StaticClass()));
		TargetableIntf_eventGetTargetingPermissions_Parms Parms;
		UFunction* const Func = O->FindFunction(SPECTRAL_GetTargetingPermissions);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (ITargetableIntf*)(O->GetNativeInterfaceAddress(UTargetableIntf::StaticClass())))
		{
			Parms.ReturnValue = I->GetTargetingPermissions_Implementation();
		}
		return Parms.ReturnValue;
	}
	void UTargeterIntf::StaticRegisterNativesUTargeterIntf()
	{
	}
	IMPLEMENT_CLASS(UTargeterIntf, 3550449262);
	void UTargetingArcIntf::StaticRegisterNativesUTargetingArcIntf()
	{
	}
	IMPLEMENT_CLASS(UTargetingArcIntf, 3952097823);
	TArray<FVector2D> ITargetingAreaIntf::GetTargetableLocations()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_GetTargetableLocations instead.");
		TargetingAreaIntf_eventGetTargetableLocations_Parms Parms;
		return Parms.ReturnValue;
	}
	TArray<TScriptInterface<ITargetableIntf> > ITargetingAreaIntf::GetTargetables()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_GetTargetables instead.");
		TargetingAreaIntf_eventGetTargetables_Parms Parms;
		return Parms.ReturnValue;
	}
	void UTargetingAreaIntf::StaticRegisterNativesUTargetingAreaIntf()
	{
		FNativeFunctionRegistrar::RegisterFunction(UTargetingAreaIntf::StaticClass(),"GetTargetableLocations",(Native)&ITargetingAreaIntf::execGetTargetableLocations);
		FNativeFunctionRegistrar::RegisterFunction(UTargetingAreaIntf::StaticClass(),"GetTargetables",(Native)&ITargetingAreaIntf::execGetTargetables);
	}
	IMPLEMENT_CLASS(UTargetingAreaIntf, 3390846824);
	TArray<FVector2D> ITargetingAreaIntf::Execute_GetTargetableLocations(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UTargetingAreaIntf::StaticClass()));
		TargetingAreaIntf_eventGetTargetableLocations_Parms Parms;
		UFunction* const Func = O->FindFunction(SPECTRAL_GetTargetableLocations);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (ITargetingAreaIntf*)(O->GetNativeInterfaceAddress(UTargetingAreaIntf::StaticClass())))
		{
			Parms.ReturnValue = I->GetTargetableLocations_Implementation();
		}
		return Parms.ReturnValue;
	}
	TArray<TScriptInterface<ITargetableIntf> > ITargetingAreaIntf::Execute_GetTargetables(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UTargetingAreaIntf::StaticClass()));
		TargetingAreaIntf_eventGetTargetables_Parms Parms;
		UFunction* const Func = O->FindFunction(SPECTRAL_GetTargetables);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (ITargetingAreaIntf*)(O->GetNativeInterfaceAddress(UTargetingAreaIntf::StaticClass())))
		{
			Parms.ReturnValue = I->GetTargetables_Implementation();
		}
		return Parms.ReturnValue;
	}
	TArray<FVector> ITargetingVolumeIntf::GetTargetableLocations()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_GetTargetableLocations instead.");
		TargetingVolumeIntf_eventGetTargetableLocations_Parms Parms;
		return Parms.ReturnValue;
	}
	TArray<TScriptInterface<ITargetableIntf> > ITargetingVolumeIntf::GetTargetables()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_GetTargetables instead.");
		TargetingVolumeIntf_eventGetTargetables_Parms Parms;
		return Parms.ReturnValue;
	}
	void UTargetingVolumeIntf::StaticRegisterNativesUTargetingVolumeIntf()
	{
		FNativeFunctionRegistrar::RegisterFunction(UTargetingVolumeIntf::StaticClass(),"GetTargetableLocations",(Native)&ITargetingVolumeIntf::execGetTargetableLocations);
		FNativeFunctionRegistrar::RegisterFunction(UTargetingVolumeIntf::StaticClass(),"GetTargetables",(Native)&ITargetingVolumeIntf::execGetTargetables);
	}
	IMPLEMENT_CLASS(UTargetingVolumeIntf, 23120294);
	TArray<FVector> ITargetingVolumeIntf::Execute_GetTargetableLocations(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UTargetingVolumeIntf::StaticClass()));
		TargetingVolumeIntf_eventGetTargetableLocations_Parms Parms;
		UFunction* const Func = O->FindFunction(SPECTRAL_GetTargetableLocations);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (ITargetingVolumeIntf*)(O->GetNativeInterfaceAddress(UTargetingVolumeIntf::StaticClass())))
		{
			Parms.ReturnValue = I->GetTargetableLocations_Implementation();
		}
		return Parms.ReturnValue;
	}
	TArray<TScriptInterface<ITargetableIntf> > ITargetingVolumeIntf::Execute_GetTargetables(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UTargetingVolumeIntf::StaticClass()));
		TargetingVolumeIntf_eventGetTargetables_Parms Parms;
		UFunction* const Func = O->FindFunction(SPECTRAL_GetTargetables);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (ITargetingVolumeIntf*)(O->GetNativeInterfaceAddress(UTargetingVolumeIntf::StaticClass())))
		{
			Parms.ReturnValue = I->GetTargetables_Implementation();
		}
		return Parms.ReturnValue;
	}
	void UTimerIntf::StaticRegisterNativesUTimerIntf()
	{
	}
	IMPLEMENT_CLASS(UTimerIntf, 1756233219);
	int32 IDiscreteTimerIntf::GetTime()
	{
		check(0 && "Do not directly call Event functions in Interfaces. Call Execute_GetTime instead.");
		DiscreteTimerIntf_eventGetTime_Parms Parms;
		return Parms.ReturnValue;
	}
	void UDiscreteTimerIntf::StaticRegisterNativesUDiscreteTimerIntf()
	{
		FNativeFunctionRegistrar::RegisterFunction(UDiscreteTimerIntf::StaticClass(),"GetTime",(Native)&IDiscreteTimerIntf::execGetTime);
	}
	IMPLEMENT_CLASS(UDiscreteTimerIntf, 994022219);
	int32 IDiscreteTimerIntf::Execute_GetTime(UObject* O)
	{
		check(O != NULL);
		check(O->GetClass()->ImplementsInterface(UDiscreteTimerIntf::StaticClass()));
		DiscreteTimerIntf_eventGetTime_Parms Parms;
		UFunction* const Func = O->FindFunction(SPECTRAL_GetTime);
		if (Func)
		{
			O->ProcessEvent(Func, &Parms);
		}
		else if (auto I = (IDiscreteTimerIntf*)(O->GetNativeInterfaceAddress(UDiscreteTimerIntf::StaticClass())))
		{
			Parms.ReturnValue = I->GetTime_Implementation();
		}
		return Parms.ReturnValue;
	}
FName SPECTRAL_AddSkill = FName(TEXT("AddSkill"));
FName SPECTRAL_AddSkillEffect = FName(TEXT("AddSkillEffect"));
FName SPECTRAL_AddSkillMod = FName(TEXT("AddSkillMod"));
FName SPECTRAL_ApplyEffect = FName(TEXT("ApplyEffect"));
FName SPECTRAL_ApplyMod = FName(TEXT("ApplyMod"));
FName SPECTRAL_ApplySkill = FName(TEXT("ApplySkill"));
FName SPECTRAL_GenerateSkillExecutor = FName(TEXT("GenerateSkillExecutor"));
FName SPECTRAL_GetEffectStorage = FName(TEXT("GetEffectStorage"));
FName SPECTRAL_GetModStorage = FName(TEXT("GetModStorage"));
FName SPECTRAL_GetSkill = FName(TEXT("GetSkill"));
FName SPECTRAL_GetSkillEffects = FName(TEXT("GetSkillEffects"));
FName SPECTRAL_GetSkillExecutor = FName(TEXT("GetSkillExecutor"));
FName SPECTRAL_GetSkillMods = FName(TEXT("GetSkillMods"));
FName SPECTRAL_GetSkillOwner = FName(TEXT("GetSkillOwner"));
FName SPECTRAL_GetSkills = FName(TEXT("GetSkills"));
FName SPECTRAL_GetSkillUserLocation = FName(TEXT("GetSkillUserLocation"));
FName SPECTRAL_GetStorage = FName(TEXT("GetStorage"));
FName SPECTRAL_GetTargetableLocation = FName(TEXT("GetTargetableLocation"));
FName SPECTRAL_GetTargetableLocations = FName(TEXT("GetTargetableLocations"));
FName SPECTRAL_GetTargetables = FName(TEXT("GetTargetables"));
FName SPECTRAL_GetTargetingPermissions = FName(TEXT("GetTargetingPermissions"));
FName SPECTRAL_GetTime = FName(TEXT("GetTime"));
FName SPECTRAL_React = FName(TEXT("React"));
FName SPECTRAL_RemoveSkillByIndex = FName(TEXT("RemoveSkillByIndex"));
FName SPECTRAL_RemoveSkillByRef = FName(TEXT("RemoveSkillByRef"));
FName SPECTRAL_RemoveSkillEffectByIndex = FName(TEXT("RemoveSkillEffectByIndex"));
FName SPECTRAL_RemoveSkillEffectByRef = FName(TEXT("RemoveSkillEffectByRef"));
FName SPECTRAL_RemoveSkillModByIndex = FName(TEXT("RemoveSkillModByIndex"));
FName SPECTRAL_RemoveSkillModByRef = FName(TEXT("RemoveSkillModByRef"));
FName SPECTRAL_RevertEffect = FName(TEXT("RevertEffect"));
FName SPECTRAL_RevertMod = FName(TEXT("RevertMod"));
#if USE_COMPILED_IN_NATIVES
// Cross Module References
	ENGINE_API class UClass* Z_Construct_UClass_AActor_NoRegister();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FVector();
	ENGINE_API class UClass* Z_Construct_UClass_AGameMode();
	ENGINE_API class UClass* Z_Construct_UClass_APawn();
	ENGINE_API class UClass* Z_Construct_UClass_USoundBase_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_USpringArmComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UCameraComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_UStaticMeshComponent_NoRegister();
	ENGINE_API class UScriptStruct* Z_Construct_UScriptStruct_FHitResult();
	ENGINE_API class UClass* Z_Construct_UClass_UPrimitiveComponent_NoRegister();
	ENGINE_API class UClass* Z_Construct_UClass_AActor();
	ENGINE_API class UClass* Z_Construct_UClass_UProjectileMovementComponent_NoRegister();
	COREUOBJECT_API class UScriptStruct* Z_Construct_UScriptStruct_FVector2D();

	SPECTRAL_API class UClass* Z_Construct_UClass_USkillEffectFactoryIntf_NoRegister();
	SPECTRAL_API class UClass* Z_Construct_UClass_USkillEffectFactoryIntf();
	SPECTRAL_API class UFunction* Z_Construct_UFunction_USkillEffectIntf_ApplyEffect();
	SPECTRAL_API class UFunction* Z_Construct_UFunction_USkillEffectIntf_GetStorage();
	SPECTRAL_API class UFunction* Z_Construct_UFunction_USkillEffectIntf_RevertEffect();
	SPECTRAL_API class UClass* Z_Construct_UClass_USkillEffectIntf_NoRegister();
	SPECTRAL_API class UClass* Z_Construct_UClass_USkillEffectIntf();
	SPECTRAL_API class UFunction* Z_Construct_UFunction_USkillEffectStorageIntf_AddSkillEffect();
	SPECTRAL_API class UFunction* Z_Construct_UFunction_USkillEffectStorageIntf_GetSkillEffects();
	SPECTRAL_API class UFunction* Z_Construct_UFunction_USkillEffectStorageIntf_RemoveSkillEffectByIndex();
	SPECTRAL_API class UFunction* Z_Construct_UFunction_USkillEffectStorageIntf_RemoveSkillEffectByRef();
	SPECTRAL_API class UClass* Z_Construct_UClass_USkillEffectStorageIntf_NoRegister();
	SPECTRAL_API class UClass* Z_Construct_UClass_USkillEffectStorageIntf();
	SPECTRAL_API class UFunction* Z_Construct_UFunction_USkillExecutorIntf_GetSkill();
	SPECTRAL_API class UFunction* Z_Construct_UFunction_USkillExecutorIntf_GetSkillOwner();
	SPECTRAL_API class UClass* Z_Construct_UClass_USkillExecutorIntf_NoRegister();
	SPECTRAL_API class UClass* Z_Construct_UClass_USkillExecutorIntf();
	SPECTRAL_API class UClass* Z_Construct_UClass_USkillFactoryIntf_NoRegister();
	SPECTRAL_API class UClass* Z_Construct_UClass_USkillFactoryIntf();
	SPECTRAL_API class UFunction* Z_Construct_UFunction_USkillIntf_ApplySkill();
	SPECTRAL_API class UFunction* Z_Construct_UFunction_USkillIntf_GetEffectStorage();
	SPECTRAL_API class UFunction* Z_Construct_UFunction_USkillIntf_GetModStorage();
	SPECTRAL_API class UFunction* Z_Construct_UFunction_USkillIntf_GetSkillExecutor();
	SPECTRAL_API class UClass* Z_Construct_UClass_USkillIntf_NoRegister();
	SPECTRAL_API class UClass* Z_Construct_UClass_USkillIntf();
	SPECTRAL_API class UClass* Z_Construct_UClass_USkillModFactoryIntf_NoRegister();
	SPECTRAL_API class UClass* Z_Construct_UClass_USkillModFactoryIntf();
	SPECTRAL_API class UFunction* Z_Construct_UFunction_USkillModIntf_ApplyMod();
	SPECTRAL_API class UFunction* Z_Construct_UFunction_USkillModIntf_RevertMod();
	SPECTRAL_API class UClass* Z_Construct_UClass_USkillModIntf_NoRegister();
	SPECTRAL_API class UClass* Z_Construct_UClass_USkillModIntf();
	SPECTRAL_API class UFunction* Z_Construct_UFunction_USkillModStorageIntf_AddSkillMod();
	SPECTRAL_API class UFunction* Z_Construct_UFunction_USkillModStorageIntf_GetSkillMods();
	SPECTRAL_API class UFunction* Z_Construct_UFunction_USkillModStorageIntf_RemoveSkillModByIndex();
	SPECTRAL_API class UFunction* Z_Construct_UFunction_USkillModStorageIntf_RemoveSkillModByRef();
	SPECTRAL_API class UClass* Z_Construct_UClass_USkillModStorageIntf_NoRegister();
	SPECTRAL_API class UClass* Z_Construct_UClass_USkillModStorageIntf();
	SPECTRAL_API class UFunction* Z_Construct_UFunction_USkillReactiveIntf_React();
	SPECTRAL_API class UClass* Z_Construct_UClass_USkillReactiveIntf_NoRegister();
	SPECTRAL_API class UClass* Z_Construct_UClass_USkillReactiveIntf();
	SPECTRAL_API class UFunction* Z_Construct_UFunction_USkillStorageIntf_AddSkill();
	SPECTRAL_API class UFunction* Z_Construct_UFunction_USkillStorageIntf_GetSkills();
	SPECTRAL_API class UFunction* Z_Construct_UFunction_USkillStorageIntf_RemoveSkillByIndex();
	SPECTRAL_API class UFunction* Z_Construct_UFunction_USkillStorageIntf_RemoveSkillByRef();
	SPECTRAL_API class UClass* Z_Construct_UClass_USkillStorageIntf_NoRegister();
	SPECTRAL_API class UClass* Z_Construct_UClass_USkillStorageIntf();
	SPECTRAL_API class UFunction* Z_Construct_UFunction_USkillUserIntf_GenerateSkillExecutor();
	SPECTRAL_API class UFunction* Z_Construct_UFunction_USkillUserIntf_GetSkills();
	SPECTRAL_API class UFunction* Z_Construct_UFunction_USkillUserIntf_GetSkillUserLocation();
	SPECTRAL_API class UClass* Z_Construct_UClass_USkillUserIntf_NoRegister();
	SPECTRAL_API class UClass* Z_Construct_UClass_USkillUserIntf();
	SPECTRAL_API class UClass* Z_Construct_UClass_ASpectralGameMode_NoRegister();
	SPECTRAL_API class UClass* Z_Construct_UClass_ASpectralGameMode();
	SPECTRAL_API class UClass* Z_Construct_UClass_ASpectralPawn_NoRegister();
	SPECTRAL_API class UClass* Z_Construct_UClass_ASpectralPawn();
	SPECTRAL_API class UFunction* Z_Construct_UFunction_ASpectralProjectile_OnHit();
	SPECTRAL_API class UClass* Z_Construct_UClass_ASpectralProjectile_NoRegister();
	SPECTRAL_API class UClass* Z_Construct_UClass_ASpectralProjectile();
	SPECTRAL_API class UClass* Z_Construct_UClass_UTargetingPermissionsIntf_NoRegister();
	SPECTRAL_API class UClass* Z_Construct_UClass_UTargetingPermissionsIntf();
	SPECTRAL_API class UFunction* Z_Construct_UFunction_UTargetableIntf_GetTargetableLocation();
	SPECTRAL_API class UFunction* Z_Construct_UFunction_UTargetableIntf_GetTargetingPermissions();
	SPECTRAL_API class UClass* Z_Construct_UClass_UTargetableIntf_NoRegister();
	SPECTRAL_API class UClass* Z_Construct_UClass_UTargetableIntf();
	SPECTRAL_API class UClass* Z_Construct_UClass_UTargeterIntf_NoRegister();
	SPECTRAL_API class UClass* Z_Construct_UClass_UTargeterIntf();
	SPECTRAL_API class UClass* Z_Construct_UClass_UTargetingArcIntf_NoRegister();
	SPECTRAL_API class UClass* Z_Construct_UClass_UTargetingArcIntf();
	SPECTRAL_API class UFunction* Z_Construct_UFunction_UTargetingAreaIntf_GetTargetableLocations();
	SPECTRAL_API class UFunction* Z_Construct_UFunction_UTargetingAreaIntf_GetTargetables();
	SPECTRAL_API class UClass* Z_Construct_UClass_UTargetingAreaIntf_NoRegister();
	SPECTRAL_API class UClass* Z_Construct_UClass_UTargetingAreaIntf();
	SPECTRAL_API class UFunction* Z_Construct_UFunction_UTargetingVolumeIntf_GetTargetableLocations();
	SPECTRAL_API class UFunction* Z_Construct_UFunction_UTargetingVolumeIntf_GetTargetables();
	SPECTRAL_API class UClass* Z_Construct_UClass_UTargetingVolumeIntf_NoRegister();
	SPECTRAL_API class UClass* Z_Construct_UClass_UTargetingVolumeIntf();
	SPECTRAL_API class UClass* Z_Construct_UClass_UTimerIntf_NoRegister();
	SPECTRAL_API class UClass* Z_Construct_UClass_UTimerIntf();
	SPECTRAL_API class UFunction* Z_Construct_UFunction_UDiscreteTimerIntf_GetTime();
	SPECTRAL_API class UClass* Z_Construct_UClass_UDiscreteTimerIntf_NoRegister();
	SPECTRAL_API class UClass* Z_Construct_UClass_UDiscreteTimerIntf();
	SPECTRAL_API class UPackage* Z_Construct_UPackage_Spectral();
	UClass* Z_Construct_UClass_USkillEffectFactoryIntf_NoRegister()
	{
		return USkillEffectFactoryIntf::StaticClass();
	}
	UClass* Z_Construct_UClass_USkillEffectFactoryIntf()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			UInterface::StaticClass();
			Z_Construct_UPackage_Spectral();
			OuterClass = USkillEffectFactoryIntf::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20104081;


				OuterClass->StaticLink();
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_USkillEffectFactoryIntf(Z_Construct_UClass_USkillEffectFactoryIntf, TEXT("USkillEffectFactoryIntf"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(USkillEffectFactoryIntf);
	UFunction* Z_Construct_UFunction_USkillEffectIntf_ApplyEffect()
	{
		UObject* Outer=Z_Construct_UClass_USkillEffectIntf();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ApplyEffect"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x0C420C00, 65535, sizeof(SkillEffectIntf_eventApplyEffect_Parms));
			UProperty* NewProp_Skill = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Skill"), RF_Public|RF_Transient|RF_Native) UInterfaceProperty(CPP_PROPERTY_BASE(Skill, SkillEffectIntf_eventApplyEffect_Parms), 0x0004000008000182, Z_Construct_UClass_USkillUserIntf_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SkillEffectIntf"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Skills/SkillFramework/SkillEffectIntf.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("* Applies the modifications made by this SkillEffect on a given SkillUser."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkillEffectIntf_GetStorage()
	{
		UObject* Outer=Z_Construct_UClass_USkillEffectIntf();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetStorage"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(SkillEffectIntf_eventGetStorage_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UInterfaceProperty(CPP_PROPERTY_BASE(ReturnValue, SkillEffectIntf_eventGetStorage_Parms), 0x0004000000000580, Z_Construct_UClass_USkillEffectStorageIntf_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SkillEffectIntf"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Skills/SkillFramework/SkillEffectIntf.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("* Returns a reference to the containing Storage object."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkillEffectIntf_RevertEffect()
	{
		UObject* Outer=Z_Construct_UClass_USkillEffectIntf();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RevertEffect"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x0C420C00, 65535, sizeof(SkillEffectIntf_eventRevertEffect_Parms));
			UProperty* NewProp_Skill = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Skill"), RF_Public|RF_Transient|RF_Native) UInterfaceProperty(CPP_PROPERTY_BASE(Skill, SkillEffectIntf_eventRevertEffect_Parms), 0x0004000008000182, Z_Construct_UClass_USkillUserIntf_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SkillEffectIntf"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Skills/SkillFramework/SkillEffectIntf.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("* Reverts the modifications made by this SkillEffect on a given SkillUser."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_USkillEffectIntf_NoRegister()
	{
		return USkillEffectIntf::StaticClass();
	}
	UClass* Z_Construct_UClass_USkillEffectIntf()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			UInterface::StaticClass();
			Z_Construct_UPackage_Spectral();
			OuterClass = USkillEffectIntf::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20104081;

				OuterClass->LinkChild(Z_Construct_UFunction_USkillEffectIntf_ApplyEffect());
				OuterClass->LinkChild(Z_Construct_UFunction_USkillEffectIntf_GetStorage());
				OuterClass->LinkChild(Z_Construct_UFunction_USkillEffectIntf_RevertEffect());

				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkillEffectIntf_ApplyEffect()); // 4111314751
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkillEffectIntf_GetStorage()); // 2354421630
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkillEffectIntf_RevertEffect()); // 4001044500
				OuterClass->StaticLink();
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_USkillEffectIntf(Z_Construct_UClass_USkillEffectIntf, TEXT("USkillEffectIntf"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(USkillEffectIntf);
	UFunction* Z_Construct_UFunction_USkillEffectStorageIntf_AddSkillEffect()
	{
		UObject* Outer=Z_Construct_UClass_USkillEffectStorageIntf();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AddSkillEffect"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x0C420C00, 65535, sizeof(SkillEffectStorageIntf_eventAddSkillEffect_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UInterfaceProperty(CPP_PROPERTY_BASE(ReturnValue, SkillEffectStorageIntf_eventAddSkillEffect_Parms), 0x0004000000000580, Z_Construct_UClass_USkillEffectIntf_NoRegister());
			UProperty* NewProp_Index = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Index"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(Index, SkillEffectStorageIntf_eventAddSkillEffect_Parms), 0x0000000000000080);
			UProperty* NewProp_SkillEffect = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SkillEffect"), RF_Public|RF_Transient|RF_Native) UInterfaceProperty(CPP_PROPERTY_BASE(SkillEffect, SkillEffectStorageIntf_eventAddSkillEffect_Parms), 0x0004000008000182, Z_Construct_UClass_USkillEffectIntf_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SkillEffectStorageIntf"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Skills/SkillFramework/SkillEffectStorageIntf.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("* Adds a new SkillEffect to the array of skill effects. Index = -1 should imply insertion\n* into the end of the container."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkillEffectStorageIntf_GetSkillEffects()
	{
		UObject* Outer=Z_Construct_UClass_USkillEffectStorageIntf();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetSkillEffects"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x5C020C00, 65535, sizeof(SkillEffectStorageIntf_eventGetSkillEffects_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(ReturnValue, SkillEffectStorageIntf_eventGetSkillEffects_Parms), 0x0004000000000580);
			UProperty* NewProp_ReturnValue_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ReturnValue, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UInterfaceProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0004000000000000, Z_Construct_UClass_USkillEffectIntf_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SkillEffectStorageIntf"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Skills/SkillFramework/SkillEffectStorageIntf.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("* Returns an array of the SkillEffects managed by the SkillEffectStorage."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkillEffectStorageIntf_RemoveSkillEffectByIndex()
	{
		UObject* Outer=Z_Construct_UClass_USkillEffectStorageIntf();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RemoveSkillEffectByIndex"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(SkillEffectStorageIntf_eventRemoveSkillEffectByIndex_Parms));
			UProperty* NewProp_Index = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Index"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(Index, SkillEffectStorageIntf_eventRemoveSkillEffectByIndex_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SkillEffectStorageIntf"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Skills/SkillFramework/SkillEffectStorageIntf.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("* Removes the SkillEffect at Index from the array of skill effects."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkillEffectStorageIntf_RemoveSkillEffectByRef()
	{
		UObject* Outer=Z_Construct_UClass_USkillEffectStorageIntf();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RemoveSkillEffectByRef"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x0C420C00, 65535, sizeof(SkillEffectStorageIntf_eventRemoveSkillEffectByRef_Parms));
			UProperty* NewProp_SkillEffect = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SkillEffect"), RF_Public|RF_Transient|RF_Native) UInterfaceProperty(CPP_PROPERTY_BASE(SkillEffect, SkillEffectStorageIntf_eventRemoveSkillEffectByRef_Parms), 0x0004000008000182, Z_Construct_UClass_USkillEffectIntf_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SkillEffectStorageIntf"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Skills/SkillFramework/SkillEffectStorageIntf.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("* Removes the referenced SkillEffect from the array of skill effects."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_USkillEffectStorageIntf_NoRegister()
	{
		return USkillEffectStorageIntf::StaticClass();
	}
	UClass* Z_Construct_UClass_USkillEffectStorageIntf()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			UInterface::StaticClass();
			Z_Construct_UPackage_Spectral();
			OuterClass = USkillEffectStorageIntf::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20104081;

				OuterClass->LinkChild(Z_Construct_UFunction_USkillEffectStorageIntf_AddSkillEffect());
				OuterClass->LinkChild(Z_Construct_UFunction_USkillEffectStorageIntf_GetSkillEffects());
				OuterClass->LinkChild(Z_Construct_UFunction_USkillEffectStorageIntf_RemoveSkillEffectByIndex());
				OuterClass->LinkChild(Z_Construct_UFunction_USkillEffectStorageIntf_RemoveSkillEffectByRef());

				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkillEffectStorageIntf_AddSkillEffect()); // 2434087524
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkillEffectStorageIntf_GetSkillEffects()); // 990506481
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkillEffectStorageIntf_RemoveSkillEffectByIndex()); // 2891675389
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkillEffectStorageIntf_RemoveSkillEffectByRef()); // 3412690568
				OuterClass->StaticLink();
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_USkillEffectStorageIntf(Z_Construct_UClass_USkillEffectStorageIntf, TEXT("USkillEffectStorageIntf"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(USkillEffectStorageIntf);
	UFunction* Z_Construct_UFunction_USkillExecutorIntf_GetSkill()
	{
		UObject* Outer=Z_Construct_UClass_USkillExecutorIntf();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetSkill"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(SkillExecutorIntf_eventGetSkill_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UInterfaceProperty(CPP_PROPERTY_BASE(ReturnValue, SkillExecutorIntf_eventGetSkill_Parms), 0x0004000000000580, Z_Construct_UClass_USkillIntf_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SkillIntf"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Skills/SkillFramework/SkillExecutorIntf.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkillExecutorIntf_GetSkillOwner()
	{
		UObject* Outer=Z_Construct_UClass_USkillExecutorIntf();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetSkillOwner"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(SkillExecutorIntf_eventGetSkillOwner_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UInterfaceProperty(CPP_PROPERTY_BASE(ReturnValue, SkillExecutorIntf_eventGetSkillOwner_Parms), 0x0004000000000580, Z_Construct_UClass_USkillUserIntf_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SkillIntf"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Skills/SkillFramework/SkillExecutorIntf.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("* Provides access to the SkillExecutor that distributed the Skill."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_USkillExecutorIntf_NoRegister()
	{
		return USkillExecutorIntf::StaticClass();
	}
	UClass* Z_Construct_UClass_USkillExecutorIntf()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			UInterface::StaticClass();
			Z_Construct_UPackage_Spectral();
			OuterClass = USkillExecutorIntf::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20104081;

				OuterClass->LinkChild(Z_Construct_UFunction_USkillExecutorIntf_GetSkill());
				OuterClass->LinkChild(Z_Construct_UFunction_USkillExecutorIntf_GetSkillOwner());

				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkillExecutorIntf_GetSkill()); // 2882728509
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkillExecutorIntf_GetSkillOwner()); // 1821287466
				OuterClass->StaticLink();
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_USkillExecutorIntf(Z_Construct_UClass_USkillExecutorIntf, TEXT("USkillExecutorIntf"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(USkillExecutorIntf);
	UClass* Z_Construct_UClass_USkillFactoryIntf_NoRegister()
	{
		return USkillFactoryIntf::StaticClass();
	}
	UClass* Z_Construct_UClass_USkillFactoryIntf()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			UInterface::StaticClass();
			Z_Construct_UPackage_Spectral();
			OuterClass = USkillFactoryIntf::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20104081;


				OuterClass->StaticLink();
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_USkillFactoryIntf(Z_Construct_UClass_USkillFactoryIntf, TEXT("USkillFactoryIntf"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(USkillFactoryIntf);
	UFunction* Z_Construct_UFunction_USkillIntf_ApplySkill()
	{
		UObject* Outer=Z_Construct_UClass_USkillIntf();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ApplySkill"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x0C420C00, 65535, sizeof(SkillIntf_eventApplySkill_Parms));
			UProperty* NewProp_Target = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Target"), RF_Public|RF_Transient|RF_Native) UInterfaceProperty(CPP_PROPERTY_BASE(Target, SkillIntf_eventApplySkill_Parms), 0x0004000008000182, Z_Construct_UClass_USkillUserIntf_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SkillIntf"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Skills/SkillFramework/SkillIntf.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("* Applies all SkillEffects within the Skill to the specified Target."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkillIntf_GetEffectStorage()
	{
		UObject* Outer=Z_Construct_UClass_USkillIntf();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetEffectStorage"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(SkillIntf_eventGetEffectStorage_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UInterfaceProperty(CPP_PROPERTY_BASE(ReturnValue, SkillIntf_eventGetEffectStorage_Parms), 0x0004000000000580, Z_Construct_UClass_USkillEffectStorageIntf_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SkillIntf"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Skills/SkillFramework/SkillIntf.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("* Provides access to the EffectStorage responsible for managing the relationship\n* between SkillEffects and the Skill they are associated with."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkillIntf_GetModStorage()
	{
		UObject* Outer=Z_Construct_UClass_USkillIntf();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetModStorage"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(SkillIntf_eventGetModStorage_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UInterfaceProperty(CPP_PROPERTY_BASE(ReturnValue, SkillIntf_eventGetModStorage_Parms), 0x0004000000000580, Z_Construct_UClass_USkillModStorageIntf_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SkillIntf"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Skills/SkillFramework/SkillIntf.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("* Provides access to the ModStorage responsible for managing the relationship\n* between SkillMods and the Skill they are associated with."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkillIntf_GetSkillExecutor()
	{
		UObject* Outer=Z_Construct_UClass_USkillIntf();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetSkillExecutor"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(SkillIntf_eventGetSkillExecutor_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UInterfaceProperty(CPP_PROPERTY_BASE(ReturnValue, SkillIntf_eventGetSkillExecutor_Parms), 0x0004000000000580, Z_Construct_UClass_USkillExecutorIntf_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SkillIntf"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Skills/SkillFramework/SkillIntf.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("* Provides access to the SkillExecutor that distributed the Skill."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_USkillIntf_NoRegister()
	{
		return USkillIntf::StaticClass();
	}
	UClass* Z_Construct_UClass_USkillIntf()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			UInterface::StaticClass();
			Z_Construct_UPackage_Spectral();
			OuterClass = USkillIntf::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20104081;

				OuterClass->LinkChild(Z_Construct_UFunction_USkillIntf_ApplySkill());
				OuterClass->LinkChild(Z_Construct_UFunction_USkillIntf_GetEffectStorage());
				OuterClass->LinkChild(Z_Construct_UFunction_USkillIntf_GetModStorage());
				OuterClass->LinkChild(Z_Construct_UFunction_USkillIntf_GetSkillExecutor());

				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkillIntf_ApplySkill()); // 1693120112
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkillIntf_GetEffectStorage()); // 1921352047
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkillIntf_GetModStorage()); // 2249285755
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkillIntf_GetSkillExecutor()); // 3485223694
				OuterClass->StaticLink();
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_USkillIntf(Z_Construct_UClass_USkillIntf, TEXT("USkillIntf"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(USkillIntf);
	UClass* Z_Construct_UClass_USkillModFactoryIntf_NoRegister()
	{
		return USkillModFactoryIntf::StaticClass();
	}
	UClass* Z_Construct_UClass_USkillModFactoryIntf()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			UInterface::StaticClass();
			Z_Construct_UPackage_Spectral();
			OuterClass = USkillModFactoryIntf::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20104081;


				OuterClass->StaticLink();
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_USkillModFactoryIntf(Z_Construct_UClass_USkillModFactoryIntf, TEXT("USkillModFactoryIntf"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(USkillModFactoryIntf);
	UFunction* Z_Construct_UFunction_USkillModIntf_ApplyMod()
	{
		UObject* Outer=Z_Construct_UClass_USkillModIntf();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("ApplyMod"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x0C420C00, 65535, sizeof(SkillModIntf_eventApplyMod_Parms));
			UProperty* NewProp_Skill = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Skill"), RF_Public|RF_Transient|RF_Native) UInterfaceProperty(CPP_PROPERTY_BASE(Skill, SkillModIntf_eventApplyMod_Parms), 0x0004000008000182, Z_Construct_UClass_USkillIntf_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SkillModIntf"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Skills/SkillFramework/SkillModIntf.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("* Applies the modifications associated with this SkillMod to a given Skill."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkillModIntf_RevertMod()
	{
		UObject* Outer=Z_Construct_UClass_USkillModIntf();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RevertMod"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x0C420C00, 65535, sizeof(SkillModIntf_eventRevertMod_Parms));
			UProperty* NewProp_Skill = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Skill"), RF_Public|RF_Transient|RF_Native) UInterfaceProperty(CPP_PROPERTY_BASE(Skill, SkillModIntf_eventRevertMod_Parms), 0x0004000008000182, Z_Construct_UClass_USkillIntf_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SkillModIntf"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Skills/SkillFramework/SkillModIntf.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("* Reverts the modifications associated with this SkillMod on a given Skill."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_USkillModIntf_NoRegister()
	{
		return USkillModIntf::StaticClass();
	}
	UClass* Z_Construct_UClass_USkillModIntf()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			UInterface::StaticClass();
			Z_Construct_UPackage_Spectral();
			OuterClass = USkillModIntf::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20104081;

				OuterClass->LinkChild(Z_Construct_UFunction_USkillModIntf_ApplyMod());
				OuterClass->LinkChild(Z_Construct_UFunction_USkillModIntf_RevertMod());

				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkillModIntf_ApplyMod()); // 2767904071
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkillModIntf_RevertMod()); // 835198596
				OuterClass->StaticLink();
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_USkillModIntf(Z_Construct_UClass_USkillModIntf, TEXT("USkillModIntf"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(USkillModIntf);
	UFunction* Z_Construct_UFunction_USkillModStorageIntf_AddSkillMod()
	{
		UObject* Outer=Z_Construct_UClass_USkillModStorageIntf();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AddSkillMod"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x0C420C00, 65535, sizeof(SkillModStorageIntf_eventAddSkillMod_Parms));
			UProperty* NewProp_SkillMod = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SkillMod"), RF_Public|RF_Transient|RF_Native) UInterfaceProperty(CPP_PROPERTY_BASE(SkillMod, SkillModStorageIntf_eventAddSkillMod_Parms), 0x0004000008000182, Z_Construct_UClass_USkillModIntf_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SkillModStorageIntf"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Skills/SkillFramework/SkillModStorageIntf.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("* Adds a new SkillMod to the array of skill effects."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkillModStorageIntf_GetSkillMods()
	{
		UObject* Outer=Z_Construct_UClass_USkillModStorageIntf();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetSkillMods"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x5C020C00, 65535, sizeof(SkillModStorageIntf_eventGetSkillMods_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(ReturnValue, SkillModStorageIntf_eventGetSkillMods_Parms), 0x0004000000000580);
			UProperty* NewProp_ReturnValue_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ReturnValue, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UInterfaceProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0004000000000000, Z_Construct_UClass_USkillModIntf_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SkillModStorageIntf"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Skills/SkillFramework/SkillModStorageIntf.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("* Returns an array of the SkillMods managed by the SkillModStorage."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkillModStorageIntf_RemoveSkillModByIndex()
	{
		UObject* Outer=Z_Construct_UClass_USkillModStorageIntf();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RemoveSkillModByIndex"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(SkillModStorageIntf_eventRemoveSkillModByIndex_Parms));
			UProperty* NewProp_Index = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Index"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(Index, SkillModStorageIntf_eventRemoveSkillModByIndex_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SkillModStorageIntf"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Skills/SkillFramework/SkillModStorageIntf.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("* Removes the SkillMod at Index from the array of skill effects."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkillModStorageIntf_RemoveSkillModByRef()
	{
		UObject* Outer=Z_Construct_UClass_USkillModStorageIntf();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RemoveSkillModByRef"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x0C420C00, 65535, sizeof(SkillModStorageIntf_eventRemoveSkillModByRef_Parms));
			UProperty* NewProp_SkillMod = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SkillMod"), RF_Public|RF_Transient|RF_Native) UInterfaceProperty(CPP_PROPERTY_BASE(SkillMod, SkillModStorageIntf_eventRemoveSkillModByRef_Parms), 0x0004000008000182, Z_Construct_UClass_USkillModIntf_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SkillModStorageIntf"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Skills/SkillFramework/SkillModStorageIntf.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("* Removes the referenced SkillMod from the array of skill effects."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_USkillModStorageIntf_NoRegister()
	{
		return USkillModStorageIntf::StaticClass();
	}
	UClass* Z_Construct_UClass_USkillModStorageIntf()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			UInterface::StaticClass();
			Z_Construct_UPackage_Spectral();
			OuterClass = USkillModStorageIntf::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20104081;

				OuterClass->LinkChild(Z_Construct_UFunction_USkillModStorageIntf_AddSkillMod());
				OuterClass->LinkChild(Z_Construct_UFunction_USkillModStorageIntf_GetSkillMods());
				OuterClass->LinkChild(Z_Construct_UFunction_USkillModStorageIntf_RemoveSkillModByIndex());
				OuterClass->LinkChild(Z_Construct_UFunction_USkillModStorageIntf_RemoveSkillModByRef());

				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkillModStorageIntf_AddSkillMod()); // 1283527195
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkillModStorageIntf_GetSkillMods()); // 948145095
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkillModStorageIntf_RemoveSkillModByIndex()); // 225746575
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkillModStorageIntf_RemoveSkillModByRef()); // 220211174
				OuterClass->StaticLink();
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_USkillModStorageIntf(Z_Construct_UClass_USkillModStorageIntf, TEXT("USkillModStorageIntf"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(USkillModStorageIntf);
	UFunction* Z_Construct_UFunction_USkillReactiveIntf_React()
	{
		UObject* Outer=Z_Construct_UClass_USkillReactiveIntf();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("React"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SkillReactiveIntf"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Skills/SkillFramework/SkillReactiveIntf.h"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_USkillReactiveIntf_NoRegister()
	{
		return USkillReactiveIntf::StaticClass();
	}
	UClass* Z_Construct_UClass_USkillReactiveIntf()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			UInterface::StaticClass();
			Z_Construct_UPackage_Spectral();
			OuterClass = USkillReactiveIntf::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20104081;

				OuterClass->LinkChild(Z_Construct_UFunction_USkillReactiveIntf_React());

				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkillReactiveIntf_React()); // 273272993
				OuterClass->StaticLink();
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_USkillReactiveIntf(Z_Construct_UClass_USkillReactiveIntf, TEXT("USkillReactiveIntf"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(USkillReactiveIntf);
	UFunction* Z_Construct_UFunction_USkillStorageIntf_AddSkill()
	{
		UObject* Outer=Z_Construct_UClass_USkillStorageIntf();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("AddSkill"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x0C420C00, 65535, sizeof(SkillStorageIntf_eventAddSkill_Parms));
			UProperty* NewProp_Skill = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Skill"), RF_Public|RF_Transient|RF_Native) UInterfaceProperty(CPP_PROPERTY_BASE(Skill, SkillStorageIntf_eventAddSkill_Parms), 0x0004000008000182, Z_Construct_UClass_USkillIntf_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SkillStorageIntf"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Skills/SkillFramework/SkillStorageIntf.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("* Adds a new SkillMod to the array of skill effects."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkillStorageIntf_GetSkills()
	{
		UObject* Outer=Z_Construct_UClass_USkillStorageIntf();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetSkills"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x5C020C00, 65535, sizeof(SkillStorageIntf_eventGetSkills_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(ReturnValue, SkillStorageIntf_eventGetSkills_Parms), 0x0004000000000580);
			UProperty* NewProp_ReturnValue_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ReturnValue, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UInterfaceProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0004000000000000, Z_Construct_UClass_USkillIntf_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SkillStorageIntf"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Skills/SkillFramework/SkillStorageIntf.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("* Returns an array of the SkillMods managed by the SkillStorage."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkillStorageIntf_RemoveSkillByIndex()
	{
		UObject* Outer=Z_Construct_UClass_USkillStorageIntf();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RemoveSkillByIndex"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(SkillStorageIntf_eventRemoveSkillByIndex_Parms));
			UProperty* NewProp_Index = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Index"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(Index, SkillStorageIntf_eventRemoveSkillByIndex_Parms), 0x0000000000000080);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SkillStorageIntf"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Skills/SkillFramework/SkillStorageIntf.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("* Removes the SkillMod at Index from the array of skill effects."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkillStorageIntf_RemoveSkillByRef()
	{
		UObject* Outer=Z_Construct_UClass_USkillStorageIntf();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("RemoveSkillByRef"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x0C420C00, 65535, sizeof(SkillStorageIntf_eventRemoveSkillByRef_Parms));
			UProperty* NewProp_Skill = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Skill"), RF_Public|RF_Transient|RF_Native) UInterfaceProperty(CPP_PROPERTY_BASE(Skill, SkillStorageIntf_eventRemoveSkillByRef_Parms), 0x0004000008000182, Z_Construct_UClass_USkillIntf_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SkillStorageIntf"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Skills/SkillFramework/SkillStorageIntf.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("* Removes the referenced SkillMod from the array of skill effects."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_USkillStorageIntf_NoRegister()
	{
		return USkillStorageIntf::StaticClass();
	}
	UClass* Z_Construct_UClass_USkillStorageIntf()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			UInterface::StaticClass();
			Z_Construct_UPackage_Spectral();
			OuterClass = USkillStorageIntf::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20104081;

				OuterClass->LinkChild(Z_Construct_UFunction_USkillStorageIntf_AddSkill());
				OuterClass->LinkChild(Z_Construct_UFunction_USkillStorageIntf_GetSkills());
				OuterClass->LinkChild(Z_Construct_UFunction_USkillStorageIntf_RemoveSkillByIndex());
				OuterClass->LinkChild(Z_Construct_UFunction_USkillStorageIntf_RemoveSkillByRef());

				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkillStorageIntf_AddSkill()); // 4209517476
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkillStorageIntf_GetSkills()); // 2881403479
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkillStorageIntf_RemoveSkillByIndex()); // 1528333819
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkillStorageIntf_RemoveSkillByRef()); // 3530260921
				OuterClass->StaticLink();
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_USkillStorageIntf(Z_Construct_UClass_USkillStorageIntf, TEXT("USkillStorageIntf"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(USkillStorageIntf);
	UFunction* Z_Construct_UFunction_USkillUserIntf_GenerateSkillExecutor()
	{
		UObject* Outer=Z_Construct_UClass_USkillUserIntf();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GenerateSkillExecutor"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x0C420C00, 65535, sizeof(SkillUserIntf_eventGenerateSkillExecutor_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UInterfaceProperty(CPP_PROPERTY_BASE(ReturnValue, SkillUserIntf_eventGenerateSkillExecutor_Parms), 0x0004000000000580, Z_Construct_UClass_USkillExecutorIntf_NoRegister());
			UProperty* NewProp_SkillIndex = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("SkillIndex"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(SkillIndex, SkillUserIntf_eventGenerateSkillExecutor_Parms), 0x0000000000000080);
			UProperty* NewProp_TargetingMethod = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("TargetingMethod"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(TargetingMethod, SkillUserIntf_eventGenerateSkillExecutor_Parms), 0x0000000008000182);
			UProperty* NewProp_TargetingMethod_Inner = new(EC_InternalUseOnlyConstructor, NewProp_TargetingMethod, TEXT("TargetingMethod"), RF_Public|RF_Transient|RF_Native) UObjectProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UClass_AActor_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SkillUserIntf"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Skills/SkillFramework/SkillUserIntf.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("* A Factory Method intended to generate the appropriate SkillExecutor based on\n* the contents of the TargetingMethod array.\n*\n* - If targetingMethod can be cast to TArray<TScriptInterface<ISkillUserIntf>>,\n*   then the targets are assumed to be each of the provided references.\n*\n* - Else if TargetingMethod can be cast to TArray<TScriptInterface<TargetingVolumeIntf>>,\n*   then the targets are assumed to be all entities within the supplied sequence of volumes.\n*\n* - Else if TargetingMethod can be cast to TArray<TScriptInterface<TargetingAreaIntf>>,\n*   then the targets are assumed to be all entities within the supplied sequence of areas.\n*\n* - Else if TargetingMethod can be cast to TArray<TScriptInterface<TargetingArcIntf>>,\n*   then the targets are assumed to be all entities within arcs of a variable width, depth,\n*   and orientation from each of a set of points (analogous to \"directed lines\", but abstracted,\n*   i.e. an extremely deep, yet thin arc could be considered a line, for all intents and purposes).\n*\n* Subclasses of AActor were selected because it would ensure that the object...\n* - can be replicated.\n* - has a transform.\n* - can be rendered."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkillUserIntf_GetSkills()
	{
		UObject* Outer=Z_Construct_UClass_USkillUserIntf();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetSkills"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(SkillUserIntf_eventGetSkills_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(ReturnValue, SkillUserIntf_eventGetSkills_Parms), 0x0004000000000580);
			UProperty* NewProp_ReturnValue_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ReturnValue, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UInterfaceProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0004000000000000, Z_Construct_UClass_USkillIntf_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SkillUserIntf"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Skills/SkillFramework/SkillUserIntf.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("* Returns an array of Skills associated with the SkillUser."));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_USkillUserIntf_GetSkillUserLocation()
	{
		UObject* Outer=Z_Construct_UClass_USkillUserIntf();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetSkillUserLocation"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x0C820C00, 65535, sizeof(SkillUserIntf_eventGetSkillUserLocation_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, SkillUserIntf_eventGetSkillUserLocation_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("SkillUserIntf"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("Skills/SkillFramework/SkillUserIntf.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("* Returns the location of the SkillUser as a 3-dimensional vector.\n* Assumed to only reference the X,Y axes in 2D considerations."));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_USkillUserIntf_NoRegister()
	{
		return USkillUserIntf::StaticClass();
	}
	UClass* Z_Construct_UClass_USkillUserIntf()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			UInterface::StaticClass();
			Z_Construct_UPackage_Spectral();
			OuterClass = USkillUserIntf::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20104081;

				OuterClass->LinkChild(Z_Construct_UFunction_USkillUserIntf_GenerateSkillExecutor());
				OuterClass->LinkChild(Z_Construct_UFunction_USkillUserIntf_GetSkills());
				OuterClass->LinkChild(Z_Construct_UFunction_USkillUserIntf_GetSkillUserLocation());

				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkillUserIntf_GenerateSkillExecutor()); // 1760700840
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkillUserIntf_GetSkills()); // 2668774844
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_USkillUserIntf_GetSkillUserLocation()); // 2368337823
				OuterClass->StaticLink();
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_USkillUserIntf(Z_Construct_UClass_USkillUserIntf, TEXT("USkillUserIntf"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(USkillUserIntf);
	UClass* Z_Construct_UClass_ASpectralGameMode_NoRegister()
	{
		return ASpectralGameMode::StaticClass();
	}
	UClass* Z_Construct_UClass_ASpectralGameMode()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AGameMode();
			Z_Construct_UPackage_Spectral();
			OuterClass = ASpectralGameMode::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x2088028C;


				OuterClass->ClassConfigName = FName(TEXT("Game"));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Info Rendering MovementReplication Replication Actor Input Movement Collision Rendering Utilities|Transformation"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("SpectralGameMode.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("SpectralGameMode.h"));
				MetaData->SetValue(OuterClass, TEXT("ShowCategories"), TEXT("Input|MouseInput Input|TouchInput"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ASpectralGameMode(Z_Construct_UClass_ASpectralGameMode, TEXT("ASpectralGameMode"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(ASpectralGameMode);
	UClass* Z_Construct_UClass_ASpectralPawn_NoRegister()
	{
		return ASpectralPawn::StaticClass();
	}
	UClass* Z_Construct_UClass_ASpectralPawn()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_APawn();
			Z_Construct_UPackage_Spectral();
			OuterClass = ASpectralPawn::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20800080;


PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_FireSound = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FireSound"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(FireSound, ASpectralPawn), 0x0000000000000005, Z_Construct_UClass_USoundBase_NoRegister());
				UProperty* NewProp_MoveSpeed = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("MoveSpeed"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(MoveSpeed, ASpectralPawn), 0x0000000000000005);
				UProperty* NewProp_FireRate = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("FireRate"), RF_Public|RF_Transient|RF_Native) UFloatProperty(CPP_PROPERTY_BASE(FireRate, ASpectralPawn), 0x0000000000000005);
				UProperty* NewProp_GunOffset = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("GunOffset"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(GunOffset, ASpectralPawn), 0x0000000000000005, Z_Construct_UScriptStruct_FVector());
				UProperty* NewProp_CameraBoom = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CameraBoom"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(CameraBoom, ASpectralPawn), 0x00000000000a001d, Z_Construct_UClass_USpringArmComponent_NoRegister());
				UProperty* NewProp_CameraComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("CameraComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(CameraComponent, ASpectralPawn), 0x00000000000a001d, Z_Construct_UClass_UCameraComponent_NoRegister());
				UProperty* NewProp_ShipMeshComponent = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ShipMeshComponent"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ShipMeshComponent, ASpectralPawn), 0x00000000000b001d, Z_Construct_UClass_UStaticMeshComponent_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("BlueprintType"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("HideCategories"), TEXT("Navigation"));
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("SpectralPawn.h"));
				MetaData->SetValue(OuterClass, TEXT("IsBlueprintBase"), TEXT("true"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("SpectralPawn.h"));
				MetaData->SetValue(NewProp_FireSound, TEXT("Category"), TEXT("Audio"));
				MetaData->SetValue(NewProp_FireSound, TEXT("ModuleRelativePath"), TEXT("SpectralPawn.h"));
				MetaData->SetValue(NewProp_FireSound, TEXT("ToolTip"), TEXT("Sound to play each time we fire"));
				MetaData->SetValue(NewProp_MoveSpeed, TEXT("Category"), TEXT("Gameplay"));
				MetaData->SetValue(NewProp_MoveSpeed, TEXT("ModuleRelativePath"), TEXT("SpectralPawn.h"));
				MetaData->SetValue(NewProp_MoveSpeed, TEXT("ToolTip"), TEXT("The speed our ship moves around the level"));
				MetaData->SetValue(NewProp_FireRate, TEXT("Category"), TEXT("Gameplay"));
				MetaData->SetValue(NewProp_FireRate, TEXT("ModuleRelativePath"), TEXT("SpectralPawn.h"));
				MetaData->SetValue(NewProp_FireRate, TEXT("ToolTip"), TEXT("How fast the weapon will fire"));
				MetaData->SetValue(NewProp_GunOffset, TEXT("Category"), TEXT("Gameplay"));
				MetaData->SetValue(NewProp_GunOffset, TEXT("ModuleRelativePath"), TEXT("SpectralPawn.h"));
				MetaData->SetValue(NewProp_GunOffset, TEXT("ToolTip"), TEXT("Offset from the ships location to spawn projectiles"));
				MetaData->SetValue(NewProp_CameraBoom, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_CameraBoom, TEXT("Category"), TEXT("Camera"));
				MetaData->SetValue(NewProp_CameraBoom, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_CameraBoom, TEXT("ModuleRelativePath"), TEXT("SpectralPawn.h"));
				MetaData->SetValue(NewProp_CameraBoom, TEXT("ToolTip"), TEXT("Camera boom positioning the camera above the character"));
				MetaData->SetValue(NewProp_CameraComponent, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_CameraComponent, TEXT("Category"), TEXT("Camera"));
				MetaData->SetValue(NewProp_CameraComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_CameraComponent, TEXT("ModuleRelativePath"), TEXT("SpectralPawn.h"));
				MetaData->SetValue(NewProp_CameraComponent, TEXT("ToolTip"), TEXT("The camera"));
				MetaData->SetValue(NewProp_ShipMeshComponent, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_ShipMeshComponent, TEXT("Category"), TEXT("Mesh"));
				MetaData->SetValue(NewProp_ShipMeshComponent, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_ShipMeshComponent, TEXT("ModuleRelativePath"), TEXT("SpectralPawn.h"));
				MetaData->SetValue(NewProp_ShipMeshComponent, TEXT("ToolTip"), TEXT("The mesh component"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ASpectralPawn(Z_Construct_UClass_ASpectralPawn, TEXT("ASpectralPawn"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(ASpectralPawn);
	UFunction* Z_Construct_UFunction_ASpectralProjectile_OnHit()
	{
		struct SpectralProjectile_eventOnHit_Parms
		{
			AActor* OtherActor;
			UPrimitiveComponent* OtherComp;
			FVector NormalImpulse;
			FHitResult Hit;
		};
		UObject* Outer=Z_Construct_UClass_ASpectralProjectile();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("OnHit"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x00C20401, 65535, sizeof(SpectralProjectile_eventOnHit_Parms));
			UProperty* NewProp_Hit = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("Hit"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(Hit, SpectralProjectile_eventOnHit_Parms), 0x0000008008000182, Z_Construct_UScriptStruct_FHitResult());
			UProperty* NewProp_NormalImpulse = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("NormalImpulse"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(NormalImpulse, SpectralProjectile_eventOnHit_Parms), 0x0000000000000080, Z_Construct_UScriptStruct_FVector());
			UProperty* NewProp_OtherComp = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OtherComp"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(OtherComp, SpectralProjectile_eventOnHit_Parms), 0x0000000000080080, Z_Construct_UClass_UPrimitiveComponent_NoRegister());
			UProperty* NewProp_OtherActor = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("OtherActor"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(OtherActor, SpectralProjectile_eventOnHit_Parms), 0x0000000000000080, Z_Construct_UClass_AActor_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("SpectralProjectile.h"));
			MetaData->SetValue(ReturnFunction, TEXT("ToolTip"), TEXT("Function to handle the projectile hitting something"));
			MetaData->SetValue(NewProp_OtherComp, TEXT("EditInline"), TEXT("true"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_ASpectralProjectile_NoRegister()
	{
		return ASpectralProjectile::StaticClass();
	}
	UClass* Z_Construct_UClass_ASpectralProjectile()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_AActor();
			Z_Construct_UPackage_Spectral();
			OuterClass = ASpectralProjectile::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20800080;

				OuterClass->LinkChild(Z_Construct_UFunction_ASpectralProjectile_OnHit());

PRAGMA_DISABLE_DEPRECATION_WARNINGS
				UProperty* NewProp_ProjectileMovement = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ProjectileMovement"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ProjectileMovement, ASpectralProjectile), 0x00000000000a001d, Z_Construct_UClass_UProjectileMovementComponent_NoRegister());
				UProperty* NewProp_ProjectileMesh = new(EC_InternalUseOnlyConstructor, OuterClass, TEXT("ProjectileMesh"), RF_Public|RF_Transient|RF_Native) UObjectProperty(CPP_PROPERTY_BASE(ProjectileMesh, ASpectralProjectile), 0x00000000000a001d, Z_Construct_UClass_UStaticMeshComponent_NoRegister());
PRAGMA_ENABLE_DEPRECATION_WARNINGS
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_ASpectralProjectile_OnHit()); // 1447371424
				OuterClass->ClassConfigName = FName(TEXT("Game"));
				OuterClass->StaticLink();
#if WITH_METADATA
				UMetaData* MetaData = OuterClass->GetOutermost()->GetMetaData();
				MetaData->SetValue(OuterClass, TEXT("IncludePath"), TEXT("SpectralProjectile.h"));
				MetaData->SetValue(OuterClass, TEXT("ModuleRelativePath"), TEXT("SpectralProjectile.h"));
				MetaData->SetValue(NewProp_ProjectileMovement, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_ProjectileMovement, TEXT("Category"), TEXT("Movement"));
				MetaData->SetValue(NewProp_ProjectileMovement, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_ProjectileMovement, TEXT("ModuleRelativePath"), TEXT("SpectralProjectile.h"));
				MetaData->SetValue(NewProp_ProjectileMovement, TEXT("ToolTip"), TEXT("Projectile movement component"));
				MetaData->SetValue(NewProp_ProjectileMesh, TEXT("AllowPrivateAccess"), TEXT("true"));
				MetaData->SetValue(NewProp_ProjectileMesh, TEXT("Category"), TEXT("Projectile"));
				MetaData->SetValue(NewProp_ProjectileMesh, TEXT("EditInline"), TEXT("true"));
				MetaData->SetValue(NewProp_ProjectileMesh, TEXT("ModuleRelativePath"), TEXT("SpectralProjectile.h"));
				MetaData->SetValue(NewProp_ProjectileMesh, TEXT("ToolTip"), TEXT("Sphere collision component"));
#endif
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_ASpectralProjectile(Z_Construct_UClass_ASpectralProjectile, TEXT("ASpectralProjectile"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(ASpectralProjectile);
	UClass* Z_Construct_UClass_UTargetingPermissionsIntf_NoRegister()
	{
		return UTargetingPermissionsIntf::StaticClass();
	}
	UClass* Z_Construct_UClass_UTargetingPermissionsIntf()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			UInterface::StaticClass();
			Z_Construct_UPackage_Spectral();
			OuterClass = UTargetingPermissionsIntf::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20104081;


				OuterClass->StaticLink();
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UTargetingPermissionsIntf(Z_Construct_UClass_UTargetingPermissionsIntf, TEXT("UTargetingPermissionsIntf"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UTargetingPermissionsIntf);
	UFunction* Z_Construct_UFunction_UTargetableIntf_GetTargetableLocation()
	{
		UObject* Outer=Z_Construct_UClass_UTargetableIntf();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetTargetableLocation"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x0C820C00, 65535, sizeof(TargetableIntf_eventGetTargetableLocation_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(CPP_PROPERTY_BASE(ReturnValue, TargetableIntf_eventGetTargetableLocation_Parms), 0x0000000000000580, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("TargetableIntf"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("TargetingSystem/TargetingFramework/TargetableIntf.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UTargetableIntf_GetTargetingPermissions()
	{
		UObject* Outer=Z_Construct_UClass_UTargetableIntf();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetTargetingPermissions"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(TargetableIntf_eventGetTargetingPermissions_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UInterfaceProperty(CPP_PROPERTY_BASE(ReturnValue, TargetableIntf_eventGetTargetingPermissions_Parms), 0x0004000000000580, Z_Construct_UClass_UTargetingPermissionsIntf_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("TargetableIntf"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("TargetingSystem/TargetingFramework/TargetableIntf.h"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UTargetableIntf_NoRegister()
	{
		return UTargetableIntf::StaticClass();
	}
	UClass* Z_Construct_UClass_UTargetableIntf()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			UInterface::StaticClass();
			Z_Construct_UPackage_Spectral();
			OuterClass = UTargetableIntf::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20104081;

				OuterClass->LinkChild(Z_Construct_UFunction_UTargetableIntf_GetTargetableLocation());
				OuterClass->LinkChild(Z_Construct_UFunction_UTargetableIntf_GetTargetingPermissions());

				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UTargetableIntf_GetTargetableLocation()); // 3568518446
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UTargetableIntf_GetTargetingPermissions()); // 1456590430
				OuterClass->StaticLink();
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UTargetableIntf(Z_Construct_UClass_UTargetableIntf, TEXT("UTargetableIntf"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UTargetableIntf);
	UClass* Z_Construct_UClass_UTargeterIntf_NoRegister()
	{
		return UTargeterIntf::StaticClass();
	}
	UClass* Z_Construct_UClass_UTargeterIntf()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			UInterface::StaticClass();
			Z_Construct_UPackage_Spectral();
			OuterClass = UTargeterIntf::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20104081;


				OuterClass->StaticLink();
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UTargeterIntf(Z_Construct_UClass_UTargeterIntf, TEXT("UTargeterIntf"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UTargeterIntf);
	UClass* Z_Construct_UClass_UTargetingArcIntf_NoRegister()
	{
		return UTargetingArcIntf::StaticClass();
	}
	UClass* Z_Construct_UClass_UTargetingArcIntf()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			UInterface::StaticClass();
			Z_Construct_UPackage_Spectral();
			OuterClass = UTargetingArcIntf::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20104081;


				OuterClass->StaticLink();
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UTargetingArcIntf(Z_Construct_UClass_UTargetingArcIntf, TEXT("UTargetingArcIntf"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UTargetingArcIntf);
	UFunction* Z_Construct_UFunction_UTargetingAreaIntf_GetTargetableLocations()
	{
		UObject* Outer=Z_Construct_UClass_UTargetingAreaIntf();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetTargetableLocations"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(TargetingAreaIntf_eventGetTargetableLocations_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(ReturnValue, TargetingAreaIntf_eventGetTargetableLocations_Parms), 0x0000000000000580);
			UProperty* NewProp_ReturnValue_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ReturnValue, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FVector2D());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("TargetingAreaIntf"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("TargetingSystem/TargetingFramework/TargetingAreaIntf.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UTargetingAreaIntf_GetTargetables()
	{
		UObject* Outer=Z_Construct_UClass_UTargetingAreaIntf();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetTargetables"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(TargetingAreaIntf_eventGetTargetables_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(ReturnValue, TargetingAreaIntf_eventGetTargetables_Parms), 0x0004000000000580);
			UProperty* NewProp_ReturnValue_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ReturnValue, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UInterfaceProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0004000000000000, Z_Construct_UClass_UTargetableIntf_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("TargetingAreaIntf"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("TargetingSystem/TargetingFramework/TargetingAreaIntf.h"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UTargetingAreaIntf_NoRegister()
	{
		return UTargetingAreaIntf::StaticClass();
	}
	UClass* Z_Construct_UClass_UTargetingAreaIntf()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			UInterface::StaticClass();
			Z_Construct_UPackage_Spectral();
			OuterClass = UTargetingAreaIntf::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20104081;

				OuterClass->LinkChild(Z_Construct_UFunction_UTargetingAreaIntf_GetTargetableLocations());
				OuterClass->LinkChild(Z_Construct_UFunction_UTargetingAreaIntf_GetTargetables());

				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UTargetingAreaIntf_GetTargetableLocations()); // 184418019
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UTargetingAreaIntf_GetTargetables()); // 1285001311
				OuterClass->StaticLink();
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UTargetingAreaIntf(Z_Construct_UClass_UTargetingAreaIntf, TEXT("UTargetingAreaIntf"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UTargetingAreaIntf);
	UFunction* Z_Construct_UFunction_UTargetingVolumeIntf_GetTargetableLocations()
	{
		UObject* Outer=Z_Construct_UClass_UTargetingVolumeIntf();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetTargetableLocations"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(TargetingVolumeIntf_eventGetTargetableLocations_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(ReturnValue, TargetingVolumeIntf_eventGetTargetableLocations_Parms), 0x0000000000000580);
			UProperty* NewProp_ReturnValue_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ReturnValue, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UStructProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0000000000000000, Z_Construct_UScriptStruct_FVector());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("TargetingVolumeIntf"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("TargetingSystem/TargetingFramework/TargetingVolumeIntf.h"));
#endif
		}
		return ReturnFunction;
	}
	UFunction* Z_Construct_UFunction_UTargetingVolumeIntf_GetTargetables()
	{
		UObject* Outer=Z_Construct_UClass_UTargetingVolumeIntf();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetTargetables"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(TargetingVolumeIntf_eventGetTargetables_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UArrayProperty(CPP_PROPERTY_BASE(ReturnValue, TargetingVolumeIntf_eventGetTargetables_Parms), 0x0004000000000580);
			UProperty* NewProp_ReturnValue_Inner = new(EC_InternalUseOnlyConstructor, NewProp_ReturnValue, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UInterfaceProperty(FObjectInitializer(), EC_CppProperty, 0, 0x0004000000000000, Z_Construct_UClass_UTargetableIntf_NoRegister());
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("TargetingVolumeIntf"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("TargetingSystem/TargetingFramework/TargetingVolumeIntf.h"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UTargetingVolumeIntf_NoRegister()
	{
		return UTargetingVolumeIntf::StaticClass();
	}
	UClass* Z_Construct_UClass_UTargetingVolumeIntf()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			UInterface::StaticClass();
			Z_Construct_UPackage_Spectral();
			OuterClass = UTargetingVolumeIntf::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20104081;

				OuterClass->LinkChild(Z_Construct_UFunction_UTargetingVolumeIntf_GetTargetableLocations());
				OuterClass->LinkChild(Z_Construct_UFunction_UTargetingVolumeIntf_GetTargetables());

				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UTargetingVolumeIntf_GetTargetableLocations()); // 2107467629
				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UTargetingVolumeIntf_GetTargetables()); // 3532913685
				OuterClass->StaticLink();
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UTargetingVolumeIntf(Z_Construct_UClass_UTargetingVolumeIntf, TEXT("UTargetingVolumeIntf"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UTargetingVolumeIntf);
	UClass* Z_Construct_UClass_UTimerIntf_NoRegister()
	{
		return UTimerIntf::StaticClass();
	}
	UClass* Z_Construct_UClass_UTimerIntf()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			UInterface::StaticClass();
			Z_Construct_UPackage_Spectral();
			OuterClass = UTimerIntf::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20104081;


				OuterClass->StaticLink();
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UTimerIntf(Z_Construct_UClass_UTimerIntf, TEXT("UTimerIntf"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UTimerIntf);
	UFunction* Z_Construct_UFunction_UDiscreteTimerIntf_GetTime()
	{
		UObject* Outer=Z_Construct_UClass_UDiscreteTimerIntf();
		static UFunction* ReturnFunction = NULL;
		if (!ReturnFunction)
		{
			ReturnFunction = new(EC_InternalUseOnlyConstructor, Outer, TEXT("GetTime"), RF_Public|RF_Transient|RF_Native) UFunction(FObjectInitializer(), NULL, 0x0C020C00, 65535, sizeof(DiscreteTimerIntf_eventGetTime_Parms));
			UProperty* NewProp_ReturnValue = new(EC_InternalUseOnlyConstructor, ReturnFunction, TEXT("ReturnValue"), RF_Public|RF_Transient|RF_Native) UIntProperty(CPP_PROPERTY_BASE(ReturnValue, DiscreteTimerIntf_eventGetTime_Parms), 0x0000000000000580);
			ReturnFunction->Bind();
			ReturnFunction->StaticLink();
#if WITH_METADATA
			UMetaData* MetaData = ReturnFunction->GetOutermost()->GetMetaData();
			MetaData->SetValue(ReturnFunction, TEXT("Category"), TEXT("DiscreteTimerIntf"));
			MetaData->SetValue(ReturnFunction, TEXT("ModuleRelativePath"), TEXT("TimerSystem/TimerFramework/DiscreteTimerIntf.h"));
#endif
		}
		return ReturnFunction;
	}
	UClass* Z_Construct_UClass_UDiscreteTimerIntf_NoRegister()
	{
		return UDiscreteTimerIntf::StaticClass();
	}
	UClass* Z_Construct_UClass_UDiscreteTimerIntf()
	{
		static UClass* OuterClass = NULL;
		if (!OuterClass)
		{
			Z_Construct_UClass_UTimerIntf();
			Z_Construct_UPackage_Spectral();
			OuterClass = UDiscreteTimerIntf::StaticClass();
			if (!(OuterClass->ClassFlags & CLASS_Constructed))
			{
				UObjectForceRegistration(OuterClass);
				OuterClass->ClassFlags |= 0x20104081;

				OuterClass->LinkChild(Z_Construct_UFunction_UDiscreteTimerIntf_GetTime());

				OuterClass->AddFunctionToFunctionMap(Z_Construct_UFunction_UDiscreteTimerIntf_GetTime()); // 691538504
				OuterClass->StaticLink();
			}
		}
		check(OuterClass->GetClass());
		return OuterClass;
	}
	static FCompiledInDefer Z_CompiledInDefer_UClass_UDiscreteTimerIntf(Z_Construct_UClass_UDiscreteTimerIntf, TEXT("UDiscreteTimerIntf"));
	DEFINE_VTABLE_PTR_HELPER_CTOR(UDiscreteTimerIntf);
	UPackage* Z_Construct_UPackage_Spectral()
	{
		static UPackage* ReturnPackage = NULL;
		if (!ReturnPackage)
		{
			ReturnPackage = CastChecked<UPackage>(StaticFindObjectFast(UPackage::StaticClass(), NULL, FName(TEXT("/Script/Spectral")), false, false));
			ReturnPackage->SetPackageFlags(PKG_CompiledIn | 0x00000000);
			FGuid Guid;
			Guid.A = 0x550972AD;
			Guid.B = 0xAF989981;
			Guid.C = 0x00000000;
			Guid.D = 0x00000000;
			ReturnPackage->SetGuid(Guid);

		}
		return ReturnPackage;
	}
#endif

PRAGMA_ENABLE_DEPRECATION_WARNINGS
